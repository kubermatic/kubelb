# Copyright 2026 The KubeLB Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Cross-tenant L7 Ingress Test
# Verifies:
# - Same Ingress name works across different tenants
# - Each tenant gets separate Route CRD in their namespace
# - Tenant isolation - each Ingress gets status independently
apiVersion: chainsaw.kyverno.io/v1alpha1
kind: Test
metadata:
  name: cross-tenant-ingress
  labels:
    all:
    multi-tenant: "true"
    test: cross-tenant-ingress
    resource: ingress
    layer: layer7
spec:
  description: |
    Test tenant isolation with same Ingress name.
    Creates Ingress "shared-name" on both tenant1 and tenant2,
    verifies separate Route CRDs in tenant-primary and tenant-secondary namespaces,
    and confirms each gets status independently.
  bindings:
    - name: name
      value: shared-name
    - name: message_tenant1
      value: "hello-from-tenant1-ingress"
    - name: message_tenant2
      value: "hello-from-tenant2-ingress"
  steps:
    # Step 1: Deploy echo server on tenant1
    - name: deploy-echo-tenant1
      description: Deploy echo server on tenant1
      cluster: tenant1
      bindings:
        - name: message
          value: ($message_tenant1)
      try:
        - apply:
            file: ../../../../testdata/deployments/echo-server.yaml
        - apply:
            file: ../../../../testdata/services/echo-clusterip.yaml
        - assert:
            timeout: 60s
            resource:
              apiVersion: apps/v1
              kind: Deployment
              metadata:
                name: shared-name
                namespace: default
              status:
                readyReplicas: 1

    # Step 2: Deploy echo server on tenant2
    - name: deploy-echo-tenant2
      description: Deploy echo server on tenant2
      cluster: tenant2
      bindings:
        - name: message
          value: ($message_tenant2)
      try:
        - apply:
            file: ../../../../testdata/deployments/echo-server.yaml
        - apply:
            file: ../../../../testdata/services/echo-clusterip.yaml
        - assert:
            timeout: 60s
            resource:
              apiVersion: apps/v1
              kind: Deployment
              metadata:
                name: shared-name
                namespace: default
              status:
                readyReplicas: 1

    # Step 3: Create Ingress on tenant1
    - name: create-ingress-tenant1
      description: Create Ingress with kubelb class on tenant1
      cluster: tenant1
      try:
        - apply:
            resource:
              apiVersion: networking.k8s.io/v1
              kind: Ingress
              metadata:
                name: shared-name
                namespace: default
              spec:
                ingressClassName: kubelb
                rules:
                  - host: tenant1.test.local
                    http:
                      paths:
                        - path: /
                          pathType: Prefix
                          backend:
                            service:
                              name: shared-name
                              port:
                                number: 80

    # Step 4: Create Ingress on tenant2
    - name: create-ingress-tenant2
      description: Create Ingress with kubelb class on tenant2
      cluster: tenant2
      try:
        - apply:
            resource:
              apiVersion: networking.k8s.io/v1
              kind: Ingress
              metadata:
                name: shared-name
                namespace: default
              spec:
                ingressClassName: kubelb
                rules:
                  - host: tenant2.test.local
                    http:
                      paths:
                        - path: /
                          pathType: Prefix
                          backend:
                            service:
                              name: shared-name
                              port:
                                number: 80

    # Step 5: Verify Route CRDs in both tenant namespaces
    - name: verify-route-crds-both-tenants
      description: Verify separate Route CRDs for each tenant
      cluster: kubelb
      try:
        - script:
            skipCommandOutput: true
            timeout: 60s
            content: |
              set -e
              NS_PRIMARY="tenant-primary"
              NS_SECONDARY="tenant-secondary"
              INGRESS_NAME="shared-name"

              for i in $(seq 1 20); do
                ROUTE_PRIMARY=$(kubectl get routes.kubelb.k8c.io -n "$NS_PRIMARY" \
                  -l kubelb.k8c.io/origin-name="$INGRESS_NAME" -o name 2>/dev/null | head -1)
                ROUTE_SECONDARY=$(kubectl get routes.kubelb.k8c.io -n "$NS_SECONDARY" \
                  -l kubelb.k8c.io/origin-name="$INGRESS_NAME" -o name 2>/dev/null | head -1)

                if [ -n "$ROUTE_PRIMARY" ] && [ -n "$ROUTE_SECONDARY" ]; then
                  echo "SUCCESS: Route CRDs exist in both tenant namespaces"
                  echo "  $NS_PRIMARY: $ROUTE_PRIMARY"
                  echo "  $NS_SECONDARY: $ROUTE_SECONDARY"

                  # Verify labels
                  KIND_P=$(kubectl get $ROUTE_PRIMARY -n "$NS_PRIMARY" \
                    -o jsonpath='{.metadata.labels.kubelb\.k8c\.io/origin-resource-kind}')
                  KIND_S=$(kubectl get $ROUTE_SECONDARY -n "$NS_SECONDARY" \
                    -o jsonpath='{.metadata.labels.kubelb\.k8c\.io/origin-resource-kind}')

                  if [ "$KIND_P" != "Ingress.networking.k8s.io" ] || [ "$KIND_S" != "Ingress.networking.k8s.io" ]; then
                    echo "FAILED: Incorrect origin-resource-kind label"
                    exit 1
                  fi

                  echo "  Labels verified for both Routes"
                  exit 0
                fi
                echo "Attempt $i: waiting for Route CRDs..."
                sleep 2
              done

              echo "FAILED: Route CRDs not found in both namespaces"
              exit 1
            check:
              ($error == null): true

    # Step 6: Verify generated Ingresses in kubelb cluster
    - name: verify-generated-ingresses
      description: Verify Ingresses created in kubelb for both tenants
      cluster: kubelb
      try:
        - script:
            skipCommandOutput: true
            timeout: 60s
            content: |
              set -e
              NS_PRIMARY="tenant-primary"
              NS_SECONDARY="tenant-secondary"
              INGRESS_NAME="shared-name"

              for i in $(seq 1 15); do
                GEN_ING_P=$(kubectl get ingress -n "$NS_PRIMARY" \
                  -l kubelb.k8c.io/origin-name="$INGRESS_NAME" -o name 2>/dev/null | head -1)
                GEN_ING_S=$(kubectl get ingress -n "$NS_SECONDARY" \
                  -l kubelb.k8c.io/origin-name="$INGRESS_NAME" -o name 2>/dev/null | head -1)

                if [ -n "$GEN_ING_P" ] && [ -n "$GEN_ING_S" ]; then
                  echo "Generated Ingresses verified in both namespaces"
                  exit 0
                fi
                sleep 2
              done
              echo "FAILED: Generated Ingresses not found"
              exit 1
            check:
              ($error == null): true

    # Step 7: Verify tenant1 Ingress gets status
    - name: verify-status-tenant1
      description: Verify tenant1 Ingress gets LoadBalancer IP
      cluster: tenant1
      try:
        - script:
            skipCommandOutput: true
            timeout: 120s
            content: |
              set -e
              for i in $(seq 1 30); do
                IP=$(kubectl get ingress shared-name -n default \
                  -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
                if [ -n "$IP" ]; then
                  echo "Tenant1 Ingress has LoadBalancer IP: $IP"
                  exit 0
                fi
                sleep 3
              done
              echo "FAILED: Tenant1 Ingress has no LoadBalancer IP"
              exit 1
            check:
              ($error == null): true

    # Step 8: Verify tenant2 Ingress gets status
    - name: verify-status-tenant2
      description: Verify tenant2 Ingress gets LoadBalancer IP
      cluster: tenant2
      try:
        - script:
            skipCommandOutput: true
            timeout: 120s
            content: |
              set -e
              for i in $(seq 1 30); do
                IP=$(kubectl get ingress shared-name -n default \
                  -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
                if [ -n "$IP" ]; then
                  echo "Tenant2 Ingress has LoadBalancer IP: $IP"
                  exit 0
                fi
                sleep 3
              done
              echo "FAILED: Tenant2 Ingress has no LoadBalancer IP"
              exit 1
            check:
              ($error == null): true

    # Step 9: Wait for NodePort services to be created by CCM on both tenants
    - name: wait-nodeport-services
      description: Wait for CCM to create NodePort services for backends
      cluster: tenant1
      try:
        - script:
            skipCommandOutput: true
            timeout: 60s
            content: |
              set -e
              for i in $(seq 1 20); do
                SVC=$(kubectl get svc -n default -l kubelb.k8c.io/origin-name=shared-name -o name 2>/dev/null | head -1)
                if [ -n "$SVC" ]; then
                  echo "Tenant1 NodePort service created: $SVC"
                  sleep 2
                  exit 0
                fi
                echo "Attempt $i: waiting for tenant1 NodePort service..."
                sleep 2
              done
              echo "FAILED: Tenant1 NodePort service not created"
              exit 1
            check:
              ($error == null): true

    - name: wait-nodeport-services-tenant2
      description: Wait for CCM to create NodePort service on tenant2
      cluster: tenant2
      try:
        - script:
            skipCommandOutput: true
            timeout: 60s
            content: |
              set -e
              for i in $(seq 1 20); do
                SVC=$(kubectl get svc -n default -l kubelb.k8c.io/origin-name=shared-name -o name 2>/dev/null | head -1)
                if [ -n "$SVC" ]; then
                  echo "Tenant2 NodePort service created: $SVC"
                  sleep 2
                  exit 0
                fi
                echo "Attempt $i: waiting for tenant2 NodePort service..."
                sleep 2
              done
              echo "FAILED: Tenant2 NodePort service not created"
              exit 1
            check:
              ($error == null): true

    # Step 10: Verify tenant1 Ingress returns correct message
    - name: verify-http-tenant1
      description: Verify tenant1 Ingress returns tenant1 message
      cluster: tenant1
      try:
        - script:
            skipCommandOutput: true
            timeout: 60s
            content: |
              set -e
              EXPECTED="hello-from-tenant1-ingress"
              # Get IP from Ingress status (propagated from kubelb)
              IP=$(kubectl get ingress shared-name -n default \
                -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
              HOST="tenant1.test.local"

              echo "Testing tenant1 Ingress at $HOST via $IP"
              for i in $(seq 1 20); do
                RESPONSE=$(curl -s --max-time 5 -H "Host: ${HOST}" "http://${IP}/" 2>/dev/null || true)
                if echo "$RESPONSE" | grep -q "$EXPECTED"; then
                  echo "SUCCESS: Tenant1 Ingress returned '$EXPECTED'"
                  exit 0
                fi
                echo "Attempt $i: waiting..."
                sleep 2
              done

              echo "FAILED: Expected '$EXPECTED', got '$RESPONSE'"
              exit 1
            check:
              ($error == null): true

    # Step 11: Verify tenant2 Ingress returns correct message
    - name: verify-http-tenant2
      description: Verify tenant2 Ingress returns tenant2 message
      cluster: tenant2
      try:
        - script:
            skipCommandOutput: true
            timeout: 60s
            content: |
              set -e
              EXPECTED="hello-from-tenant2-ingress"
              # Get IP from Ingress status (propagated from kubelb)
              IP=$(kubectl get ingress shared-name -n default \
                -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
              HOST="tenant2.test.local"

              echo "Testing tenant2 Ingress at $HOST via $IP"
              for i in $(seq 1 20); do
                RESPONSE=$(curl -s --max-time 5 -H "Host: ${HOST}" "http://${IP}/" 2>/dev/null || true)
                if echo "$RESPONSE" | grep -q "$EXPECTED"; then
                  echo "SUCCESS: Tenant2 Ingress returned '$EXPECTED'"
                  exit 0
                fi
                echo "Attempt $i: waiting..."
                sleep 2
              done

              echo "FAILED: Expected '$EXPECTED', got '$RESPONSE'"
              exit 1
            check:
              ($error == null): true

    # Step 12: Verify unknown hostname returns 404 (proper routing isolation)
    - name: verify-unknown-host-404
      description: Verify unknown hostname returns 404
      cluster: tenant1
      try:
        - script:
            skipCommandOutput: true
            timeout: 60s
            content: |
              set -e
              # Get the LoadBalancer IP
              IP=$(kubectl get ingress shared-name -n default \
                -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
              # Use an unknown hostname
              HOST="unknown.test.local"

              echo "Testing unknown hostname returns 404"
              for i in $(seq 1 15); do
                HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 -H "Host: ${HOST}" "http://${IP}/" 2>/dev/null || echo "000")
                if [ "$HTTP_CODE" = "404" ]; then
                  echo "SUCCESS: Got 404 for unknown hostname"
                  exit 0
                fi
                echo "Attempt $i: got HTTP $HTTP_CODE, waiting..."
                sleep 2
              done

              echo "FAILED: Expected 404, got HTTP $HTTP_CODE"
              exit 1
            check:
              ($error == null): true

    # Step 13: Cleanup tenant1
    - name: cleanup-tenant1
      description: Delete Ingress on tenant1
      cluster: tenant1
      try:
        - script:
            skipCommandOutput: true
            timeout: 60s
            content: |
              kubectl delete ingress shared-name -n default --wait=false || true
              echo "Tenant1 Ingress deletion initiated"
            check:
              ($error == null): true

    # Step 14: Cleanup tenant2
    - name: cleanup-tenant2
      description: Delete Ingress on tenant2
      cluster: tenant2
      try:
        - script:
            skipCommandOutput: true
            timeout: 60s
            content: |
              kubectl delete ingress shared-name -n default --wait=false || true
              echo "Tenant2 Ingress deletion initiated"
            check:
              ($error == null): true

    # Step 15: Verify Route CRDs removed
    - name: verify-cleanup
      description: Verify Route CRDs removed from both namespaces
      cluster: kubelb
      try:
        - script:
            skipCommandOutput: true
            timeout: 60s
            content: |
              set -e
              NS_PRIMARY="tenant-primary"
              NS_SECONDARY="tenant-secondary"

              # Only check for Ingress routes - tenant2 converter creates Gateway/HTTPRoute routes too
              for i in $(seq 1 30); do
                ROUTE_P=$(kubectl get routes.kubelb.k8c.io -n "$NS_PRIMARY" \
                  -l kubelb.k8c.io/origin-name="shared-name",kubelb.k8c.io/origin-resource-kind="Ingress.networking.k8s.io" -o name 2>/dev/null | head -1)
                ROUTE_S=$(kubectl get routes.kubelb.k8c.io -n "$NS_SECONDARY" \
                  -l kubelb.k8c.io/origin-name="shared-name",kubelb.k8c.io/origin-resource-kind="Ingress.networking.k8s.io" -o name 2>/dev/null | head -1)

                if [ -z "$ROUTE_P" ] && [ -z "$ROUTE_S" ]; then
                  echo "SUCCESS: Ingress Route CRDs removed from both namespaces"
                  exit 0
                fi
                sleep 2
              done

              echo "FAILED: Ingress Route CRDs not removed"
              exit 1
            check:
              ($error == null): true
      finally:
        - script:
            skipCommandOutput: true
            cluster: tenant1
            timeout: 60s
            content: |
              kubectl delete ingress shared-name -n default --ignore-not-found
              kubectl delete deployment shared-name -n default --ignore-not-found
              kubectl delete service shared-name -n default --ignore-not-found
        - script:
            skipCommandOutput: true
            cluster: tenant2
            timeout: 60s
            content: |
              kubectl delete ingress shared-name -n default --ignore-not-found
              kubectl delete deployment shared-name -n default --ignore-not-found
              kubectl delete service shared-name -n default --ignore-not-found
              # Delete HTTPRoute created by converter
              kubectl delete httproute -n default -l "kubelb.k8c.io/source-ingress=shared-name.default" --ignore-not-found
